<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>3D Maze (Cardboard Fixed Movement)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    #overlay {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none; color: #fff;
      font-family: system-ui, sans-serif; background: rgba(0,0,0,.5);
    }
    #win {
      position: fixed; inset: 0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.75); color:#fff; font-size:28px;
      font-weight:700;
    }
  </style>
</head>
<body>
  <div id="overlay">ğŸ“± ì¹´ë“œë³´ë“œì— ë„£ê³  ë°”ë¼ë³´ë©´ ìë™ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤!</div>
  <div id="win">ğŸ‰ íƒˆì¶œ ì„±ê³µ!</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { VRButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101218);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(light);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(100,100),
      new THREE.MeshStandardMaterial({ color: 0x1e232b })
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // ë¯¸ë¡œ ë§µ
    const layout = [
      '#################',
      '#P000000#0000000#',
      '#0###0###0###0###',
      '#000#0000000#000#',
      '###0###0###0###0#',
      '#0000000#00000X0#',
      '#################'
    ];
    const CELL = 2.0, WALL_H=2.2;
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x3b4554 });
    const wallGeo = new THREE.BoxGeometry(CELL,WALL_H,CELL);
    const walls=[];
    let playerStart=new THREE.Vector3(), goalPos=null;
    for(let y=0;y<layout.length;y++){
      for(let x=0;x<layout[y].length;x++){
        const c=layout[y][x];
        if(c==='#'){
          const w=new THREE.Mesh(wallGeo,wallMat);
          w.position.set(x*CELL,WALL_H/2,y*CELL);
          scene.add(w); walls.push(w);
        }
        if(c==='P') playerStart.set(x*CELL,1.6,y*CELL);
        if(c==='X') goalPos=new THREE.Vector3(x*CELL,0.5,y*CELL);
      }
    }

    const goal=new THREE.Mesh(
      new THREE.ConeGeometry(0.5,1,16),
      new THREE.MeshStandardMaterial({ color:0x00ff88 })
    );
    goal.position.copy(goalPos);
    scene.add(goal);

    // Raycaster
    const raycaster=new THREE.Raycaster(), dir=new THREE.Vector3(), origin=new THREE.Vector3();

    // í”Œë ˆì´ì–´ ìƒíƒœ
    const player={ pos: playerStart.clone(), speed:1.2 };

    // XR ì´ë™ìš© referenceSpace
    let referenceSpace=null;
    renderer.xr.addEventListener('sessionstart', ()=>{
      const session = renderer.xr.getSession();
      session.requestReferenceSpace('local').then(ref=>{
        referenceSpace=ref;
        console.log('[XR] referenceSpace initialized');
      });
    });

    // ì¶©ëŒ ê²€ì‚¬
    function collide(next){
      for(const w of walls){
        const dx=Math.abs(next.x-w.position.x);
        const dz=Math.abs(next.z-w.position.z);
        if(dx<CELL/2 && dz<CELL/2) return true;
      }
      return false;
    }

    const clock=new THREE.Clock();
    renderer.setAnimationLoop(()=>{
      const dt=Math.min(clock.getDelta(),0.05);
      // ì´ë™ ë°©í–¥ ê³„ì‚°
      const headCam=renderer.xr.getCamera(camera);
      headCam.getWorldDirection(dir); dir.y=0; dir.normalize();

      origin.copy(player.pos); origin.y=1.6;
      raycaster.set(origin,dir);
      const hits=raycaster.intersectObjects(walls,true);
      let scale=1.0;
      if(hits.length>0 && hits[0].distance<1.0) scale=0.0;

      const move=dir.clone().multiplyScalar(player.speed*dt*scale);
      const next=player.pos.clone().add(move);
      if(!collide(next)) player.pos.copy(next);

      // VR ëª¨ë“œì¼ ë•ŒëŠ” referenceSpace offsetìœ¼ë¡œ ì´ë™
      if(renderer.xr.isPresenting && referenceSpace){
        const offset = new XRRigidTransform({x:-player.pos.x, y:-1.6, z:-player.pos.z});
        renderer.xr.setReferenceSpace(referenceSpace.getOffsetReferenceSpace(offset));
      } else {
        camera.position.copy(player.pos);
      }

      if(goalPos && player.pos.distanceTo(goalPos)<1.0){
        document.getElementById('win').style.display='flex';
      }
      renderer.render(scene,camera);
    });

    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>

<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Cardboard ë ˆì´ìºìŠ¤íŒ… XR ë¯¸ë¡œ</title>
<style>
  html, body { margin:0; height:100%; background:#000; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #ui {
    position: fixed; left: 0; right: 0; bottom: 0; padding: 8px 10px; 
    display: flex; gap: 8px; flex-wrap: wrap; align-items: center; justify-content: center;
    background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.6) 30%, rgba(0,0,0,.8) 100%);
    z-index: 5;
  }
  button, select { background:#1f1f1f; color:#eee; border:1px solid #444; border-radius:8px; padding:8px 10px; }
  button:active { transform: translateY(1px); }
  #canvas { position: fixed; inset: 0; width: 100%; height: 100%; display:block; }
  #toast {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,.7); color:#fff; padding:8px 12px; border-radius: 8px; font-size: 14px; z-index: 6;
  }
  #win {
    position: fixed; inset: 0; display: none; place-items: center; z-index: 10;
    background: rgba(0,0,0,.75);
    color: #fff; text-align:center;
  }
  #win h1 { margin: 0 0 12px 0; font-size: 32px; }
  #mapwrap {
    position: fixed; top: 10px; left: 10px; z-index: 6; background: rgba(0,0,0,.5);
    padding: 6px; border-radius: 8px; display: none;
  }
  #mapwrap textarea {
    width: 260px; height: 180px; background:#0e0e0e; color:#9fe9ff; border:1px solid #333; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  #hud {
    position: fixed; top: 10px; right: 10px; z-index: 6; background: rgba(0,0,0,.5);
    padding: 6px 8px; border-radius: 8px; font-size: 12px; line-height: 1.2;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="toast" style="display:none;"></div>

<div id="hud">yaw: <span id="yawDeg">0</span>Â°<br>pos: <span id="pos">0,0</span></div>

<div id="mapwrap">
  <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:6px;">
    <strong style="font-size:14px;">ë§µ í¸ì§‘(P, #, 0, x)</strong>
    <button id="applyMap">ì ìš©</button>
  </div>
  <textarea id="mapInput"></textarea>
</div>

<div id="win">
  <div>
    <h1>ğŸ‰ íƒˆì¶œ ì„±ê³µ!</h1>
    <p>ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì£¼ì„¸ìš”.</p>
    <button id="restart">ë‹¤ì‹œ ì‹œì‘</button>
  </div>
</div>

<div id="ui">
  <button id="perm">ì„¼ì„œ ê¶Œí•œ ìš”ì²­</button>
  <button id="autowalk">ìë™ ì „ì§„: ë”</button>
  <button id="recenter">ì‹œì„  ë¦¬ì…‹</button>
  <button id="sbs">ì¹´ë“œë³´ë“œ ëª¨ë“œ: ì¼¬</button>
  <button id="fullscreen">ì „ì²´í™”ë©´</button>
  <button id="toggleMap">ë§µ í¸ì§‘</button>
  <select id="quality">
    <option value="140">í™”ì§ˆ: ë³´í†µ</option>
    <option value="100">í™”ì§ˆ: ë‚®ìŒ(ë°°í„°ë¦¬ ì ˆì•½)</option>
    <option value="200">í™”ì§ˆ: ë†’ìŒ</option>
    <option value="280">í™”ì§ˆ: ë§¤ìš° ë†’ìŒ</option>
  </select>
</div>

<script>
(() => {
  // ----- ê²Œì„ ì„¤ì • -----
  const MAP_ASCII = `
########################
#0P00000000000#0000000x#
#0######0#####0#######0#
#000000#0#0000000000#00#
#####0##0#0########0#0##
#0000#000#00000000#0#00#
#0#######0#######0#0#0##
#0000000000000000#00000#
########################
`.trim();

  const TILE_WALL = '#', TILE_EMPTY = '0', TILE_GOAL = 'x', TILE_PLAYER = 'P';
  const CELL = 1.0;                 // ì…€ í•œ ì¹¸ í¬ê¸°(ê·¸ë¦¬ë“œ ë‹¨ìœ„)
  const MOVE_SPEED = 1.8;           // ì´ˆë‹¹ ì „ì§„ ì†ë„(ì…€/ì´ˆ)
  const ROT_SPEED_MOUSE = 0.003;    // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ íšŒì „ ê°ë„
  const IPD = 0.06;                 // ì–‘ì•ˆ ì‹œì°¨(ê°„ë‹¨ ëª¨ë¸)
  const EYE_FOV = Math.PI * 0.8;    // ëˆˆ í•œìª½ FOV(ë˜ì´ìºìŠ¤íŠ¸ ì‹œ)
  const MAX_DIST = 30.0;            // ìµœëŒ€ ë ˆì´ ê±°ë¦¬
  const GOAL_RADIUS = 0.25;         // ëª©í‘œ ë„ë‹¬ íŒì • ë°˜ê²½
  const WALL_SHADE = [0.95,0.75,0.55,0.4]; // ë²½ ì…°ì´ë”©(ì¶• íˆíŠ¸/ì‚¬ì„  ë“±)

  // ----- ìƒíƒœ -----
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const yawDegEl = document.getElementById('yawDeg');
  const posEl = document.getElementById('pos');
  const toast = document.getElementById('toast');

  let grid = [];
  let startPos = {x:1.5, y:1.5};
  let player = { x: 1.5, y: 1.5, yaw: 0 };
  let autoWalk = false;
  let sbsMode = true;
  let nColsPerEye = 140;
  let lastT = performance.now();
  let yawOffset = 0; // ë¦¬ì„¼í„°

  // ----- ë§µ íŒŒì‹± -----
  function loadMap(ascii) {
    const rows = ascii.split('\n').map(r => r.replace(/\r/g,''));
    grid = rows.map(r => r.split(''));
    for (let y=0; y<grid.length; y++) {
      for (let x=0; x<grid[y].length; x++) {
        if (grid[y][x] === TILE_PLAYER) {
          startPos = {x: x + 0.5, y: y + 0.5};
          grid[y][x] = TILE_EMPTY;
        }
      }
    }
    resetPlayer();
  }

  function resetPlayer() {
    player.x = startPos.x;
    player.y = startPos.y;
    player.yaw = 0;
    yawOffset = 0;
    autoWalk = false;
    document.getElementById('autowalk').textContent = 'ìë™ ì „ì§„: ë”';
    document.getElementById('win').style.display = 'none';
  }

  loadMap(MAP_ASCII);
  // ë§µ í¸ì§‘ UI ì´ˆê¹ƒê°’
  document.getElementById('mapInput').value = MAP_ASCII;

  // ----- ìœ í‹¸ -----
  function showToast(msg, ms=1500){ toast.textContent=msg; toast.style.display='block'; setTimeout(()=>toast.style.display='none', ms); }

  function isWall(x, y) {
    const gx = Math.floor(x), gy = Math.floor(y);
    if (gy < 0 || gy >= grid.length || gx < 0 || gx >= grid[0].length) return true;
    return grid[gy][gx] === TILE_WALL;
  }
  function isGoalAt(x, y) {
    const gx = Math.floor(x), gy = Math.floor(y);
    if (gy < 0 || gy >= grid.length || gx < 0 || gx >= grid[0].length) return false;
    return grid[gy][gx] === TILE_GOAL;
  }

  // ----- ë””ë°”ì´ìŠ¤ ì˜¤ë¦¬ì—”í…Œì´ì…˜ -----
  let hasOrientation = false;
  let yawFromDevice = 0; // ë¼ë””ì•ˆ(0 = ë™ìª½ ê¸°ì¤€ìœ¼ë¡œ í•´ë„ ê´œì°®ìŒ)
  let pitchFromDevice = 0;

  function clampAngle(a){ while(a<-Math.PI) a+=2*Math.PI; while(a>Math.PI) a-=2*Math.PI; return a; }

  function onOrientation(e) {
    hasOrientation = true;
    // ê°€ì¥ ê°„ë‹¨í•œ ëª¨ë¸: alpha(ìê¸°ì¥ ê¸°ì¤€ ë°©ìœ„) â†’ yaw, beta â†’ pitch
    // ë¸Œë¼ìš°ì €/ê¸°ê¸° í¸ì°¨ê°€ ìˆìœ¼ë¯€ë¡œ ì˜¤í”„ì…‹ ì¬ì¡°ì •(recenter) ì§€ì›
    const alpha = e.alpha ?? 0;
    const beta = e.beta ?? 0;
    // iOS webkitCompassHeading ìš°ì„ 
    const compass = e.webkitCompassHeading;
    let yawDeg = (typeof compass === 'number') ? (360 - compass) : alpha; // 0~360, ì‹œê³„ë°˜ëŒ€ CCW
    // í™”ë©´ íšŒì „ì— ë”°ë¥¸ ë³´ì •ì€ ê°„ë‹¨í™”ë¥¼ ìœ„í•´ ìƒëµ(ì¹´ë“œë³´ë“œ ê°€ë¡œ ê³ ì • ê°€ì •)
    yawFromDevice = clampAngle((yawDeg * Math.PI/180) + yawOffset);
    pitchFromDevice = (beta - 90) * Math.PI/180; // ëŒ€ëµì 
  }

  // ê¶Œí•œ ìš”ì²­(iOS ë“±)
  async function requestSensorPermission() {
    try {
      const anyDO = window.DeviceOrientationEvent;
      if (anyDO && typeof anyDO.requestPermission === 'function') {
        const st = await anyDO.requestPermission();
        if (st === 'granted') {
          window.addEventListener('deviceorientation', onOrientation, true);
          showToast('ì„¼ì„œ ì‚¬ìš© í—ˆìš©ë¨');
        } else { showToast('ì„¼ì„œ ê¶Œí•œ ê±°ë¶€ë¨'); }
      } else {
        // ì•ˆë“œë¡œì´ë“œ/ë°ìŠ¤í¬íƒ‘ ë“±: ê¶Œí•œ API ì—†ìŒ, ë°”ë¡œ ë¦¬ìŠ¤ë„ˆ
        window.addEventListener('deviceorientation', onOrientation, true);
        showToast('ì„¼ì„œ ì—°ê²° ì‹œë„');
      }
    } catch (e) {
      console.error(e);
      showToast('ì„¼ì„œ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨');
    }
  }

  // ----- ì…ë ¥(ë§ˆìš°ìŠ¤/í‚¤ë³´ë“œ) -----
  let dragging = false, lastX = 0;
  canvas.addEventListener('mousedown', (e)=>{ dragging=true; lastX=e.clientX; });
  window.addEventListener('mouseup', ()=> dragging=false);
  window.addEventListener('mousemove', (e)=>{
    if (!dragging) return;
    const dx = e.clientX - lastX; lastX = e.clientX;
    player.yaw = clampAngle(player.yaw + dx * ROT_SPEED_MOUSE);
  });
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'w' || e.key === 'ArrowUp') moveForward(0.16); // í•œ ë²ˆì— ì¡°ê¸ˆ
    if (e.key === 'ArrowLeft') player.yaw = clampAngle(player.yaw - 0.08);
    if (e.key === 'ArrowRight') player.yaw = clampAngle(player.yaw + 0.08);
  });

  // ----- ì´ë™/ì¶©ëŒ -----
  function moveForward(dt) {
    const speed = MOVE_SPEED * dt;
    const dir = playerYaw();
    const nx = player.x + Math.cos(dir) * speed;
    const ny = player.y + Math.sin(dir) * speed;

    // ê°„ë‹¨ ì¶©ëŒ ì²˜ë¦¬: ì¶•ë³„ë¡œ ë”°ë¡œ ê²€ì‚¬
    if (!isWall(nx, player.y)) player.x = nx;
    if (!isWall(player.x, ny)) player.y = ny;

    // ëª©í‘œ ë„ë‹¬ ì²´í¬
    if (isGoalAt(player.x, player.y)) {
      document.getElementById('win').style.display = 'grid';
    } else {
      // ë°˜ê²½ íŒì •
      const gx = Math.floor(player.x)+0.5, gy = Math.floor(player.y)+0.5;
      if (isGoalAt(gx, gy)) {
        const dx = player.x - gx, dy = player.y - gy;
        if (Math.hypot(dx,dy) < GOAL_RADIUS) {
          document.getElementById('win').style.display = 'grid';
        }
      }
    }
  }

  // ----- ì¹´ë©”ë¼/ì‹œì•¼ -----
  function playerYaw() {
    // ì„¼ì„œê°€ ìˆìœ¼ë©´ ê·¸ ê°’ì„, ì—†ìœ¼ë©´ ìˆ˜ë™ yaw
    const base = hasOrientation ? yawFromDevice : player.yaw;
    return base;
  }

  // ----- ë ˆì´ìºìŠ¤íŒ…(DDA) -----
  function castRay(ox, oy, ang) {
    // DDA ì•Œê³ ë¦¬ì¦˜
    const dx = Math.cos(ang), dy = Math.sin(ang);
    let mapX = Math.floor(ox), mapY = Math.floor(oy);

    const deltaDistX = Math.abs(1 / (dx || 1e-9));
    const deltaDistY = Math.abs(1 / (dy || 1e-9));

    let stepX, sideDistX;
    if (dx < 0) { stepX = -1; sideDistX = (ox - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - ox) * deltaDistX; }

    let stepY, sideDistY;
    if (dy < 0) { stepY = -1; sideDistY = (oy - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - oy) * deltaDistY; }

    let hit = false, side = 0;
    let dist = 0;

    for (let i=0; i<256; i++) {
      if (sideDistX < sideDistY) {
        sideDistX += deltaDistX;
        mapX += stepX; side = 0;
      } else {
        sideDistY += deltaDistY;
        mapY += stepY; side = 1;
      }
      if (mapY<0||mapY>=grid.length||mapX<0||mapX>=grid[0].length) { dist = MAX_DIST; break; }
      if (grid[mapY][mapX] === TILE_WALL) { hit = true; break; }
    }
    if (hit) {
      if (side === 0) dist = (mapX - ox + (1 - stepX)/2) / (dx || 1e-9);
      else dist = (mapY - oy + (1 - stepY)/2) / (dy || 1e-9);
    } else {
      dist = MAX_DIST;
    }
    return { dist, side };
  }

  // ----- ë Œë” -----
  function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  function drawEye(eyeIndex, cols, totalCols) {
    const W = canvas.width, H = canvas.height;
    const halfW = W/2;
    const eyeW = sbsMode ? halfW : W; // SBSë©´ ì ˆë°˜ì”©
    const xOffset = sbsMode ? (eyeIndex===0 ? 0 : halfW) : 0;

    // ì‹œì°¨(ì–‘ì•ˆ ìœ„ì¹˜) â€“ ê°„ë‹¨ ëª¨ë¸: ì‹œì„ ì— ìˆ˜ì§í•œ ë°©í–¥ìœ¼ë¡œ Â±IPD/2 ë§Œí¼ ëˆˆ ìœ„ì¹˜ ì´ë™
    const dir = playerYaw();
    const rightX = Math.cos(dir + Math.PI/2), rightY = Math.sin(dir + Math.PI/2);
    const ex = player.x + (eyeIndex===0 ? -IPD/2 : IPD/2) * rightX;
    const ey = player.y + (eyeIndex===0 ? -IPD/2 : IPD/2) * rightY;

    // ê° ì¹¼ëŸ¼ ë Œë”
    const colW = eyeW / cols;
    const startCol = eyeIndex===0 ? 0 : totalCols - cols;

    for (let i=0; i<cols; i++) {
      const screenX = (i / cols) * 2 - 1; // -1..1
      const rayAngle = dir + screenX * (EYE_FOV/2);
      const { dist, side } = castRay(ex, ey, rayAngle);
      const corrDist = dist * Math.cos(rayAngle - dir); // í”¼ì‰¬ì•„ì´ ë³´ì •

      // ë²½ ë†’ì´
      const wallH = Math.min(H, (CELL / (corrDist || 1e-3)) * (H / Math.tan(EYE_FOV/2)) );
      const yTop = (H - wallH)/2;
      const shade = WALL_SHADE[side ? 1 : 0] * (0.85 - Math.min(corrDist / MAX_DIST, 0.75));

      // í•˜ëŠ˜/ë°”ë‹¥ ê°„ë‹¨ ê·¸ë¼ë°ì´ì…˜
      ctx.fillStyle = '#000';
      ctx.fillRect(xOffset + i*colW, 0, Math.ceil(colW)+1, yTop);
      ctx.fillStyle = 'rgba(255,255,255,'+Math.max(0.0, Math.min(1.0, shade))+')';
      ctx.fillRect(xOffset + i*colW, yTop, Math.ceil(colW)+1, wallH);
      ctx.fillStyle = 'rgba(40,40,40,1)';
      ctx.fillRect(xOffset + i*colW, yTop+wallH, Math.ceil(colW)+1, H - (yTop+wallH));
    }

    // ê°„ë‹¨ ì‹­ìì„ (ê°€ì´ë“œ)
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#fff';
    const cx = xOffset + eyeW/2, cy = H/2;
    ctx.fillRect(cx-1, cy-12, 2, 24);
    ctx.fillRect(cx-12, cy-1, 24, 2);
    ctx.globalAlpha = 1;
  }

  function render(dt) {
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const colsPerEye = nColsPerEye;
    if (sbsMode) {
      drawEye(0, colsPerEye, colsPerEye*2);
      drawEye(1, colsPerEye, colsPerEye*2);
    } else {
      // ëª¨ë…¸ ë³´ê¸°(í…ŒìŠ¤íŠ¸ìš©)
      drawEye(0, colsPerEye, colsPerEye);
    }

    // HUD
    yawDegEl.textContent = Math.round((playerYaw()*180/Math.PI + 360) % 360);
    posEl.textContent = `${player.x.toFixed(2)}, ${player.y.toFixed(2)}`;
  }

  // ----- ë£¨í”„ -----
  function loop(t) {
    const dt = Math.min(0.05, (t - lastT)/1000);
    lastT = t;

    // ìë™ ì „ì§„
    if (autoWalk) moveForward(dt);

    render(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ----- ë²„íŠ¼/UI -----
  document.getElementById('perm').addEventListener('click', requestSensorPermission);
  document.getElementById('autowalk').addEventListener('click', ()=>{
    autoWalk = !autoWalk; 
    document.getElementById('autowalk').textContent = `ìë™ ì „ì§„: ${autoWalk?'ì¼¬':'ë”'}`;
  });
  document.getElementById('recenter').addEventListener('click', ()=>{
    // í˜„ì¬ yawë¥¼ 0ìœ¼ë¡œ ë³´ì •
    const current = hasOrientation ? yawFromDevice : player.yaw;
    yawOffset -= current; // ë³´ì •ì¹˜ ì—…ë°ì´íŠ¸
    showToast('ì‹œì„  ê¸°ì¤€ ì¬ì„¤ì • ì™„ë£Œ');
  });
  document.getElementById('sbs').addEventListener('click', ()=>{
    sbsMode = !sbsMode;
    document.getElementById('sbs').textContent = `ì¹´ë“œë³´ë“œ ëª¨ë“œ: ${sbsMode?'ì¼¬':'ë”'}`;
  });
  document.getElementById('fullscreen').addEventListener('click', ()=>{
    const el = document.documentElement;
    if (!document.fullscreenElement) el.requestFullscreen?.();
    else document.exitFullscreen?.();
  });

  // ë§µ í¸ì§‘ê¸°
  document.getElementById('toggleMap').addEventListener('click', ()=>{
    const wrap = document.getElementById('mapwrap');
    wrap.style.display = (wrap.style.display==='none' || !wrap.style.display) ? 'block' : 'none';
  });
  document.getElementById('applyMap').addEventListener('click', ()=>{
    const txt = document.getElementById('mapInput').value.trimEnd();
    try {
      loadMap(txt);
      showToast('ë§µ ì ìš© ì™„ë£Œ');
    } catch (e) {
      console.error(e);
      showToast('ë§µ ì ìš© ì‹¤íŒ¨(ì½˜ì†” í™•ì¸)');
    }
  });
  document.getElementById('restart').addEventListener('click', resetPlayer);

  // ëª¨ë°”ì¼ì—ì„œ í™”ë©´ ê¹¨ì§ ë°©ì§€(ê°€ë¡œ ê³ ì • ê¶Œì¥)
  window.addEventListener('orientationchange', ()=> setTimeout(resize, 200));
  // ì´ˆê¸°ì— ì„¼ì„œ ì‹œë„(ê¶Œí•œ í•„ìš”ì‹œ ë²„íŠ¼)
  requestSensorPermission();
})();
</script>
</body>
</html>
